# 计算机网络 学习笔记

## part1

此部分来源于 https://www.youtube.com/watch?v=_618At72evs
![](2023-11-03-00-45-53.png)

**DNS**
<img src="2023-11-03-00-46-26.png" style="height:300px;" />

1. 查浏览器的本地缓存
2. 查本地 host 文件
3. 电脑中配置的 DNS 服务器

##### step1: 本地

**TCP/IP**
| 层 | 添加的东西 |
| ---- | --------------------------- |
| 应用 | |
| 传输 | 源端口 / 目标端口（DNS 默认为 53） |
| 网络 | 源 ip / 目标 ip | |
| 链路 | 源 MAC 地址 / 目标 MAC 地址 & 校验数据|
| 物理 | |

网络层看目标 ip 地址不在自己的网段范围内，找不到 ip 地址之后，就回去找网关（一般为路由器）
链路层提供 ARP 协议获得网关的 MAC 地址（一般为路由器 LAN 口）

##### ARP Address Resolution Protocol 地址解析协议

IP Address -> MAC Address

- MAC 是设备的物理地址，它独一无二。在局域网间通信的时候，需要使用 MAC 地址。
- 在局域网间通信的时候，它知道目标的 ip 地址，需要知道目标的 MAC 地址。如果本地的 ARP 缓存中没有该信息。ARP 就会向局域网中发送一个 ARP 请求**广播**，询问某个 IP 地址对应的 MAC 地址。如果目标计算机在同一局域网中，并且处于活动状态，则会把自己的 MAC 地址发回。

##### step2: 交换机

交换机是个两层设备。它知道数据最好从哪个端口发出去。（加强版集线器）
| 层 | 操作 |
| ---- | ----------------------------------------- |
| 链路 | 查看目标 MAC 地址，把数据转发到对应的端口 |
| 物理 | |

##### step3: 路由器

| 层   | 操作                                                                      |
| ---- | ------------------------------------------------------------------------- |
| 网络 | 替换源 ip 地址和源端口号为 WAN 口 ip 地址和端口，记录在 **NAT** 映射表中  |
| 链路 | 替换源 MAC 地址和目标 MAC 地址为 WAN 口 MAC 地址和下一跳路由器的 MAC 地址 |
| 物理 |                                                                           |

网络层看目标 ip 地址，发现自己附近找不到它，于是将数据包转发到公网其他路由器（下一跳路由器）。

##### NAT Network Address Translation

私有 IP 地址 <---> 公共 IP 地址
&emsp;&emsp;NAT 用于在不同网络之间转换 IP 地址。它解决了 IPv4 地址短缺的问题，并提供了网络安全性。通过 NAT，多个主机可以共享单个公共 IP 地址，实现网络通信和连接。

##### step4: DNS 服务器

##### GFW(great firewall)

- DNS 污染（劫持）
  防火墙篡改 DNS 服务器返回的 ip 地址。发生在数据从国际互联网进入国内互联网的时候。
  早期防火墙的 DNS 污染可以通过 hosts 文件来绕过。
- TCP 重置攻击
  用户发送的数据包中的目标 ip 地址或是域名被 GFW 检测到，发现其在黑名单内。将数据包直接干掉或是伪装成目标服务器返回假数据。发生在数据从国内互联网进入国际互联网的时候。
- GFW 能看到数据内容是它进行精确阻断的原因。因此传统 VPN 会对数据加密。但是它加密后的特征非常明显。防火墙虽然看不到内容，但会知道进行了 VPN 连接。

##### ShadowSocks 协议（既加密又特征不明显）

&emsp;&emsp;当浏览器发送请求的时候，会使用代理端口发送请求。请求通过防火墙来到 ShadowSocks 代理服务器。代理服务器再与目标地址通信，并将结果返回给用户。返回结果通过防火墙回到用户的 ShadowSocks 客户端，最后发回给浏览器。
&emsp;&emsp;**重放攻击**：对付 ShadowSocks 服务器，防火墙会发起**主动探测**。来看该服务器是否运行了 ShadowSocks 的服务。它会使用用户发送的数据再给 SS 服务器发一遍。简单的 SS 会被重放攻击探测到。可以引入 plugin 来解决。
&emsp;&emsp;**http plugin** 主要起到流量伪装的作用。它往 SS 请求的字节流前面加上假的 http 请求头，伪装成正常的 http 流量，让防火墙不对其进行重放攻击。出了防火墙后剪掉假的 http 头，再发往 SS 服务器。
![](2023-11-03-23-44-53.png)
&emsp;&emsp;**trojan** 基于 https 的流量伪装。
![](2023-11-04-00-27-35.png)

## part2

##### URL URI URN

- 统一资源 定位/标志/名称 Uniform Resource Locator/Identifier/Name
- URI 用来唯一标识资源，是一种**语义上的抽象概念**。
- URL 是 URI 的一种，不仅标识了 Web 资源，还指定了操作或获取方式，同时包含访问机制和网络位置。
- URN 也是 URI 的一种。URN 的一个最好的例子是 ISBN 号，它被用来唯一地识别一本书。URN 与 URL 完全不同，因为它不包含任何协议。
  <img src="images/2024-04-02-16-25-08.png" style="zoom:25%;/">

### HTTP

此部分来源于 https://github.com/yuanyuanbyte/Blog?tab=readme-ov-file

##### 特点和缺点

- 特点：无连接、无状态、灵活、简单快速
  - 无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接。
  - 无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销，这是优点也是缺点。
  - 灵活：通过 http 协议中头部的 Content-Type 标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活。
  - 简单快速：发送请求访问某个资源时，只需传送请求方法和 URL 就可以了，使用简单。正由于 http 协议简单，使得 http 服务器的程序规模小，因而通信速度很快。
- 缺点
  - 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的。意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
  - 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改。
  - 明文传输：报文(header 部分)使用的是明文，直接将信息暴露给了外界，WIFI 陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息。
  - 队头阻塞：开启长连接时，只建立一个 TCP 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态。

##### 报文结构

由请求报文和响应报文组成：

- 请求报文：由**请求行、请求头、空行、请求体**四部分组成。
- 响应报文：由**状态行、响应头、空行、响应体**四部分组成。
  - 请求行：包含**http 方法，请求地址，http 协议以及版本**。`POST /v1/list HTTP/1.1`
  - 请求头/响应头：就是一些 key:value 来告诉服务端我要哪些内容，要注意什么类型等。
  - 空行：用来区分首部与实体，因为请求头都是 key:value 的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了。
  - 请求体：请求的参数。
  - 状态行：包含 http 协议及版本、数字状态码、状态码英文名称。`HTTP/1.1 200 OK`
  - 响应体：服务端返回的数据。

##### 常见的请求头、响应头

- 请求头
  Accept、Accept-Charset、Accept-Encoding、Accept-Language:
  浏览器能够处理的内容类型、字符集、压缩编码、当前设置的语言。
  Connection：浏览器与服务器之间连接的类型。
  Cookie：当前页面设置的任何 Cookie
  Host：发出请求的页面所在的域
  Referer：发出请求的页面的 URL
  User-Agent：浏览器的用户代理字符串
- 响应头
  Date：表示消息发送的时间，时间的描述格式由 rfc822 定义
  server: 服务器名称
  Connection：浏览器与服务器之间连接的类型
  Cache-Control：控制 HTTP 缓存
  content-type: 表示后面的文档属于什么 MIME 类型
  Pragma：只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存

##### 请求方法

- http/1.1 规定了以下请求方法(注意，都是大写):
  GET: 通常用来获取资源
  HEAD: 获取资源的元信息
  POST: 提交数据，即上传数据
  PUT: 修改数据
  DELETE: 删除资源(几乎用不到)
  CONNECT: 建立连接隧道，用于代理服务器
  OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
  TRACE: 追踪请求-响应的传输路径

- GET、POST 区别

  - 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
  - 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
  - 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在 Request body 请求体中，更适合传输敏感信息。
  - 从**幂等**性的角度，GET 是幂等的，而 POST 不是。(在编程中一个幂等操作的特点是其任意多次执行一个方法所产生的影响均与一次执行的影响相同)
  - 从 TCP 的角度，GET 请求会产生一个 TCP 数据包，把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包。GET 浏览器把 http header 和 data 一起发出去，响应成功 200，POST 先发送 header，响应 100 continue，再发送 data，响应成功 200。(并不是所有的浏览器都会发送两次数据包，Firefox 就发送一次，它的 POST 请求只发一个 TCP 包)

- PUT、POST 区别
  PUT 和 POST 都有更改指定 URI 的语义，但 PUT 被定义为**幂等**的方法，而 POST 则不是，多次调用会产生不同的结果。也就是说：

  - PUT：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以 PUT 用来改资源）
  - POST：后一个请求不会把第一个请求覆盖掉。（所以 Post 用来增资源）

- OPTIONS
  主要用途有两个：
  - 获取服务器支持的所有 HTTP 请求方法；
  - 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

##### HTTP 状态码

1xx: 指示信息——表示请求已接收，继续处理。
2xx: 成功——表示请求成功处理完毕。
3xx: 重定向——表示要完成请求必须进行进一步操作。
4xx: 客户端错误——表示请求有语法错误或请求无法实现。
5xx: 服务端错误——表示服务器未能实现合法的请求。

- **状态码** - **描述**

  - `00` - Continue 客户端应继续其请求
  - `101` - Switching Protocols 服务器根据客户端的请求切换协议。只能切换到更高级的协议。如果服务器同意变更，就会发送状态码 101。
  - `200` - OK 请求成功。通常在响应体中放有数据。
  - `204` - No Content 含义与 200 相同，但响应头后没有 body 数据。
  - `206` - Partial Content 已完成指定范围的请求(带 Range 头的 GET 请求)，场景如 video,audio 播放文件较大,文件分片和断点续传时
  - `301` - Moved Permanently 永久重定向
  - `302` - Found 临时重定向
  - `304` - Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。可以使用缓存的资源，不用在服务器获取。当协商缓存命中时会返回这个状态码。
  - `400` - Bad Request 请求有语法错误
  - `401` - Unauthorized 没有权限访问
  - `403` - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
  - `404` - Not Found 请求资源不存在
  - `408` - Request Time-out 服务器等待客户端发送的请求时间过长，超时
  - `500` - Internal Server Error 服务器内部错误，无法完成请求。
  - `501` - Not Implemented 表示客户端请求的功能还不支持，无法完成请求。
  - `503` - Service Unavailable 请求未完成，因服务器过载、宕机或维护等。

- 301 302 区别
  - 301 重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用 301 来做转址。
  - 302 状态码应用的典型场景是服务器页面路径的重新规划。
    常见场景有百度，知乎、简书等等。比如说我们要在百度进入菜鸟教程，搜索出来后有一系列的列表，我们可以选择一个去进行一个点击。点击的那个不会直接进入菜鸟教程，而是先跳转到百度设置的一个临时地址，之后再跳转到菜鸟教程真实的地址。

##### 持久连接

- HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。以当年的通信情况，都是进行容量很小的文本传输，所以问题不大。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。 **图 1**
  <image src="images/2024-03-31-00-54-00.png" style="zoom:30%;"/> <image src="images/2024-03-31-00-55-14.png" style="zoom:25%;"/><image src="images/2024-03-31-01-08-19.png" style="zoom:30%;"/>
- 为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。**图 2**
- 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，也使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。

- 管线化（pipelining）**图 3**
- HTTP 管线化是将多个 HTTP request 整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过永久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持），并且只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。

- keep-alive
  HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接，这就是长连接。
  - HTTP1.0 版本默认没有 Keep-alive ，所以要想连接得到保持，必须手动配置发送 Connection: keep-alive 字段。若想断开 keep-alive 连接，需发送 Connection:close 字段；
  - HTTP1.1 规定了默认保持长连接，数据传输完成了保持 TCP 连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 Connection：close 首部字段。
  - 开启 Keep-Alive 的优点：
    - 较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）；
    - 允许请求和应答的 HTTP 管线化；
    - 降低拥塞控制 （TCP 连接减少了）；
    - 减少了后续请求的延迟（⽆需再进⾏握⼿）；
    - 报告错误⽆需关闭 TCP 连接；
  - 开启 Keep-Alive 的缺点： - 长时间的 Tcp 连接容易导致系统资源无效占用，浪费系统资源。
    ![](images/2024-03-31-19-14-00.png)

##### HTTP 1.0、1.1 区别

- 连接方面，http1.0 默认使用非持久连接，而 http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了**host**字段，这样就可以将请求发往到同一台服务器上的不同网站。
- http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

##### 加载多张图片

在 HTTP 1 下，浏览器对一个域名下最大 TCP 连接数为 6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
在 HTTP 2 下，可以一瞬间加载出来很多资源，因为，HTTP2 支持多路复用，可以在一个 TCP 连接中发送多个 HTTP 请求。

##### 队头堵塞

HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。**解决方案**：

- 并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
- 域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

##### HTTP 版本

- 1.1

  - HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等
  - HTTP/1.1 允许范围请求，即在请求头中加入 Range 头部
  - HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部，以区分同一个物理主机中的不同虚拟主机的域名
  - HTTP/1.1 默认开启持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。

- 2
  - 新的二进制格式： HTTP/1.x 的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。二进制则不同，只识别 0 和 1 的组合。
  - 多路复用： HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行，极大的提高传输性能。
  - 头部压缩： HTTP/1.x 的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表，既避免了重复头部的传输，又减小了需要传输的大小。
  - 服务端推送：这里的服务端推送指把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。
- 3
  - 避免包阻塞： 多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题，TCP 需要等待该包重传后，才能继续传输其它流的数据包。但在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。
  - 快速重启会话： 普通基于 tcp 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。

##### 304 协商缓存 200 强缓存

- 缓存：保存资源副本并在下次请求时直接使用该副本。HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。
  <img src="images/2024-04-02-23-29-59.png" style="zoom:25%"><img src="images/2024-04-02-23-30-20.png" style="zoom:25%"><img src="images/2024-04-02-23-30-59.png" style="zoom:25%">
  ![](images/2024-04-02-23-33-35.png)![](images/2024-04-02-23-34-43.png)
- 强缓存：强缓存就是不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 。在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。

  - Expires
    Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。
  - Cache-Control
    Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：
    max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
    no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜
    no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
    private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
    public：响应可以被中间代理、CDN 等缓存
    must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
  - Pragma
    Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。
  - 例子：第一次加载，页面会向服务器请求数据，并在 Response Header 中添加 Cache-Control ，过期时间为 10 秒。第二次加载，Date 头属性未更新，可以看到浏览器直接使用了强缓存，实际没有发送请求。过了 10 秒的超时时间之后，再次请求资源。

- 协商缓存
  - 一种服务端的缓存策略。服务端判断客户端的资源，是否和服务端资源一样，如果一致则返回 304 ，反之返回 200 和最新的资源。
  - 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了`If-Modified-Since`或者`If-None-Match`的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置`Last-Modified`或者`ETag`属性。
  - ETag（响应）/ If-None-Match（请求）
    ETag / If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 "W/" 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。
  - Last-Modified（响应）/ If-Modified-Since（请求）
    Last-Modified / If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较。如果相等，返回 304 ，并加载浏览器缓存。
  - ETag / If-None-Match 的出现主要解决了 Last-Modified / If-Modified-Since 所解决不了的问题
    - 当响应头部 Response Headers 同时存在 Last-Modified 和 Etag 的值时，会优先使用 Etag ；
    - Last-Modified 只能精确到秒级；
    - 如果资源被重复生成，而内容不变，则 Etag 更精确。
    - 如果文件的修改频率在秒级以下，Last-Modified / If-Modified-Since 会错误地返回 304
    - 如果文件被修改了，但是内容没有任何变化的时候，Last-Modified / If-Modified-Since 会错误地返回 200 并返回资源

#### HTTPS

- HTTP 协议存在的问题：1. 通信使用明文（不加密），内容可能会被窃听 2. 不验证通信方的身份，可能遭遇伪装 3. 无法证明报文的完整性，可能遭遇篡改
- 在 HTTPS 中，使用传输层安全性协议(TLS)或安全套接字协议(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。
  ![](images/2024-03-31-20-04-37.png)

##### 解决内容可能被窃听的问题——加密

- 对称加密+非对称加密
  发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。

##### 解决报文可能遭篡改问题——数字签名

- 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被**篡改**，那如何校验数据的完整性呢？----校验数字签名。
- 数字签名有两种功效：
  - 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
  - 数字签名能确定消息的完整性,证明数据是否未被篡改过。
- 数字签名的生成
  将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。
- 前提
  这个过程的前提是接收方知道发送者的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给接收方。
  此时就需要引入了证书颁发机构（Certificate Authority，简称 CA），CA 数量并不多，接收方客户端内置了所有受信任 CA 的证书。CA 对发送者的公钥（和其他信息）数字签名后生成证书。

##### 数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

- 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;
- CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
- 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名。
- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

##### HTTPS HTTP 区别

- HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；
- HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协议端口是 443；
- HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全
- HTTPS 比 HTTP 对搜索引擎更友好，利于 SEO,谷歌、百度优先索引 HTTPS 网页

HTTPS 普遍认为性能消耗要大于 HTTP，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。

### TCP 与 UDP

#### TCP

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。特点：

- 面向连接：发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。
- 仅支持单播传输：每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
- 面向字节流：TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
- 可靠传输：对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
- 提供拥塞控制：当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞。
- 提供全双工通信：TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段。

#### UDP

用户数据报协议（UDP，User Datagram Protocol）是一个无连接的传输协议。特点：无连接、不可靠、快速传输。特点：

- 面向无连接：UDP 不需要三次握手建立连接的，想发数据就可以开始发送了。
- 有单播，多播，广播的功能
- UDP 是面向报文的
  发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。
- 不可靠性：首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
- 头部开销小，传输高效。UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多。

#### TCP 与 UDP

| 对比         | UDP         | TCP                            |
| ------------ | ----------- | ------------------------------ |
| 是否连接     | 无连接      | 面向连接                       |
| 是否可靠     | 不可靠      | 可靠，使用流量控制和拥塞控制   |
| 连接对象个数 | 随意        | 一对一                         |
| 传输方式     | 面向报文    | 面向字节流                     |
| 首部开销     | 首部 8 字节 | 首部最小 20 字节，最大 60 字节 |

#### 三次握手

- 在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。进行三次握手的主要作用就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。
  ![](images/2024-04-01-10-17-18.png)
- 刚开始客户端处于`Closed`的状态，服务端处于`Listen`状态。
- 第一次握手：客户端给服务端发一个 SYN(Synchronize Sequence Numbers) 报文，并指明客户端的**初始化序列号** ISN(c)。此时客户端处于 `SYN_SEND` 状态。`SYN=1 seq=ISN(c)`
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于`SYN_RCVD` 的状态。`SYN=1，ACK=1，确认号 ack=ISN(c)+1，初始序号 seq=ISN(s)`
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN(s) + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。`ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1）`

##### 目的

- **三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。**
  PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。
- 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入 TCP 连接成功状态，但是服务端在收到连接请求后就进入 TCP 连接成功状态。如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。服务端正确接收并确认应答，双方便建立了连接开始通信，通信结束后释放连接。
  数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在 某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端 ，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，由于**只有两次握手**，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
- 为什么**不是四次握手**呢？ https://blog.csdn.net/lzq603/article/details/110092371蓝军红军约定，这个例子说明，通信不可能 100%可靠，三次握手已经做好了通信的准备工作，再增加握手，并不能显著提高可靠性，而且也没有必要。

#### 四次挥手

- 建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这由 TCP 的半关闭（half-close）造成的。所谓的半关闭，其实就是 TCP 提供了连接的一端 **在结束它的发送后** 还能接收来自另一端数据的能力。
  ![](images/2024-04-01-16-16-48.png)
- **MSL**是 TCP 报文里面最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
- 刚开始双方都处于 TCP 连接成功状态，客户端或服务器均可主动发起挥手动作，假如是客户端先发起关闭请求。四次挥手的过程如下：
- 第一次挥手：客户端发出连接释放报文段`FIN=1，序号seq=u`，并停止再发送数据，主动关闭 TCP 连接，进入`FIN_WAIT1`（终止等待 1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文`ACK=1，确认号ack=u+1，序号seq=v`，服务端进入`CLOSE_WAIT`（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，没有要向客户端发出的数据，服务端发出连接释放报文段`FIN=1，ACK=1，序号seq=w，确认号ack=u+1`，服务端进入`LAST_ACK`（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到服务端的连接释放报文段后，对此发出确认报文段`ACK=1，seq=u+1，ack=w+1`，客户端进入 `TIME_WAIT`（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

##### 全双工 半关闭

TCP 是**全双工**的，因此每个方向必须单独地进行关闭。
全双工：意味着，TCP 的收发是可以在两个方向上同时进行的。在任意时刻，通信双方既可以发送数据也可以接收数据，每个方向的数据流是独立的。

半关闭：TCP 提供了连接的一端**在结束了它的发送后**还能接收来自另外一端数据的能力。但是只有很少的应用程序利用它。为了实现这个特性，编程接口必须提供一种方法来说明“我已经完成了数据的传送，并且发了 FIN 给另外一端，但是我还是想接收另外一端发送来的数据，直到结束(向我发送 FIN)”。

##### 为什么 TCP 断开连接要四次挥手

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。当服务端收到客户端的 FIN 数据包后（第一次挥手），服务端不会立即 close。因为可能还有数据没发完。
服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了（第二次挥手），但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了（第三次挥手）。客户端收到 FIN 包后发送 ACK 确认断开信息给服务端（第四次挥手）。

##### TIME_WAIT 经过 2MSL 才能进入 CLOSED

- MSL Maximum Segment Lifetime 是 TCP 报文里面最大生存时间，超过这个时间报文将被丢弃。
- 理论上，四个报文都发送完毕，就可以直接进入 CLOSED 状态了，但是网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。
- 为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在`LAST-ACK`状态的服务器收不到对连接释放报文段(FIN-ACK)的确认报文(ACK)。这个时候服务器会超时重传这个连接释放报文段(FIN-ACK)，接着客户端再重传一次确认，重新启动 2MSL 时间等待计时器，最后客户端和服务端都进入到`CLOSED`状态，都能正常的关闭。
- 假如客户端在 TIME-WAIT 状态不等待 2MSL，而是在发送完确认报文(ACK)之后立即释放连接，一旦这个确认报文(ACK)丢失的话，则无法收到服务端重传的连接释放报文段(FIN-ACK)，所以不会再发送一次确认报文，服务器收不到**确认报文**就无法正常的进入 CLOSED 关闭连接状态。

#### TCP 状态变迁

CLOSED：初始状态，表示 TCP 连接是“关闭着的”或“未打开的”
LISTEN ：表示服务器端的某个 SOCKET 处于监听状态，可以接受客户端的连接
SYN_SENT：表示客户端已发送 SYN 报文，客户端发起连接（主动打开），变成此状态，如果 SYN 超时，或者服务器不存在直接 CLOSED
SYN_RCVD ：表示服务器接收到了来自客户端请求连接的 SYN 报文
ESTABLISHED ：表示 TCP 连接已经成功建立
FIN_WAIT_1：客户端执行主动关闭，发送完 FIN 包之后便进入 FIN_WAIT_1 状态
FIN_WAIT_2：客户端发送 FIN 包之后，收到 ACK，即进入此状态，其实就是半关闭的状态
TIME_WAIT ：表示收到了对方的 FIN 报文，并发送出了 ACK 报文。 TIME_WAIT 状态下的 TCP 连接会等待 2MSL，然后即可回到 CLOSED 可用状态了
CLOSE_WAIT：接收到 FIN 之后，被动的一方进入此状态，并回复 ACK
LAST_ACK：被动的一端发送 FIN 包之后 处于 LAST_ACK 状态
CLOSING：两边同时发出 FIN 请求
![](images/2024-04-01-22-54-00.png)
