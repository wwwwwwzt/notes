# 计算机网络 学习笔记

## part1

此部分来源于 https://www.youtube.com/watch?v=_618At72evs
![](2023-11-03-00-45-53.png)

**DNS**
<img src="2023-11-03-00-46-26.png" style="height:300px;" />

1. 查浏览器的本地缓存
2. 查本地 host 文件
3. 电脑中配置的 DNS 服务器

##### step1: 本地

**TCP/IP**
| 层 | 添加的东西 |
| ---- | --------------------------- |
| 应用 | |
| 传输 | 源端口 / 目标端口（DNS 默认为 53） |
| 网络 | 源 ip / 目标 ip | |
| 链路 | 源 MAC 地址 / 目标 MAC 地址 & 校验数据|
| 物理 | |

网络层看目标 ip 地址不在自己的网段范围内，找不到 ip 地址之后，就回去找网关（一般为路由器）
链路层提供 ARP 协议获得网关的 MAC 地址（一般为路由器 LAN 口）

##### step2: 交换机

交换机是个两层设备。它知道数据最好从哪个端口发出去。（加强版集线器）
| 层 | 操作 |
| ---- | ----------------------------------------- |
| 链路 | 查看目标 MAC 地址，把数据转发到对应的端口 |
| 物理 | |

##### step3: 路由器

| 层   | 操作                                                                      |
| ---- | ------------------------------------------------------------------------- |
| 网络 | 替换源 ip 地址和源端口号为 WAN 口 ip 地址和端口，记录在 **NAT** 映射表中  |
| 链路 | 替换源 MAC 地址和目标 MAC 地址为 WAN 口 MAC 地址和下一跳路由器的 MAC 地址 |
| 物理 |                                                                           |

网络层看目标 ip 地址，发现自己附近找不到它，于是将数据包转发到公网其他路由器（下一跳路由器）。

##### step4: DNS 服务器

##### GFW(great firewall)

- DNS 污染（劫持）
  防火墙篡改 DNS 服务器返回的 ip 地址。发生在数据从国际互联网进入国内互联网的时候。
  早期防火墙的 DNS 污染可以通过 hosts 文件来绕过。
- TCP 重置攻击
  用户发送的数据包中的目标 ip 地址或是域名被 GFW 检测到，发现其在黑名单内。将数据包直接干掉或是伪装成目标服务器返回假数据。发生在数据从国内互联网进入国际互联网的时候。
- GFW 能看到数据内容是它进行精确阻断的原因。因此传统 VPN 会对数据加密。但是它加密后的特征非常明显。防火墙虽然看不到内容，但会知道进行了 VPN 连接。

##### ShadowSocks 协议（既加密又特征不明显）

&emsp;&emsp;当浏览器发送请求的时候，会使用代理端口发送请求。请求通过防火墙来到 ShadowSocks 代理服务器。代理服务器再与目标地址通信，并将结果返回给用户。返回结果通过防火墙回到用户的 ShadowSocks 客户端，最后发回给浏览器。
&emsp;&emsp;**重放攻击**：对付 ShadowSocks 服务器，防火墙会发起**主动探测**。来看该服务器是否运行了 ShadowSocks 的服务。它会使用用户发送的数据再给 SS 服务器发一遍。简单的 SS 会被重放攻击探测到。可以引入 plugin 来解决。
&emsp;&emsp;**http plugin** 主要起到流量伪装的作用。它往 SS 请求的字节流前面加上假的 http 请求头，伪装成正常的 http 流量，让防火墙不对其进行重放攻击。出了防火墙后剪掉假的 http 头，再发往 SS 服务器。
![](2023-11-03-23-44-53.png)
&emsp;&emsp;**trojan** 基于 https 的流量伪装。
![](2023-11-04-00-27-35.png)

##### ARP Address Resolution Protocol

IP Address -> MAC Address

- MAC 是设备的物理地址，它独一无二。在局域网间通信的时候，需要使用 MAC 地址。
- 在局域网间通信的时候，它知道目标的 ip 地址，需要知道目标的 MAC 地址。如果本地的 ARP 缓存中没有该信息。ARP 就会向局域网中发送一个 ARP 请求**广播**，询问某个 IP 地址对应的 MAC 地址。如果目标计算机在同一局域网中，并且处于活动状态，则会把自己的 MAC 地址发回。

##### NAT Network Address Translation

私有 IP 地址 <---> 公共 IP 地址
&emsp;&emsp;NAT 用于在不同网络之间转换 IP 地址。它解决了 IPv4 地址短缺的问题，并提供了网络安全性。通过 NAT，多个主机可以共享单个公共 IP 地址，实现网络通信和连接。

## part2

此部分来源于 https://github.com/yuanyuanbyte/Blog?tab=readme-ov-file

### HTTP

##### 特点和缺点

- 特点：无连接、无状态、灵活、简单快速
  - 无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接。
  - 无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销，这是优点也是缺点。
  - 灵活：通过 http 协议中头部的 Content-Type 标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活。
  - 简单快速：发送请求访问某个资源时，只需传送请求方法和 URL 就可以了，使用简单。正由于 http 协议简单，使得 http 服务器的程序规模小，因而通信速度很快。
- 缺点
  - 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的。意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
  - 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改。
  - 明文传输：报文(header 部分)使用的是明文，直接将信息暴露给了外界，WIFI 陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息。
  - 队头阻塞：开启长连接时，只建立一个 TCP 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态。

##### 报文结构

由请求报文和响应报文组成：

- 请求报文：由请求行、请求头、空行、请求体四部分组成。
- 响应报文：由状态行、响应头、空行、响应体四部分组成。
  - 请求行：包含 http 方法，请求地址，http 协议以及版本。`POST /v1/list HTTP/1.1`
  - 请求头/响应头：就是一些 key:value 来告诉服务端我要哪些内容，要注意什么类型等。
  - 空行：用来区分首部与实体，因为请求头都是 key:value 的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了。
  - 请求体：请求的参数。
  - 状态行：包含 http 协议及版本、数字状态码、状态码英文名称。`HTTP/1.1 200 OK`
  - 响应体：服务端返回的数据。

##### 常见的请求头、响应头

- 请求头
  Accept、Accept-Charset、Accept-Encoding、Accept-Language:
  浏览器能够处理的内容类型、字符集、压缩编码、当前设置的语言。
  Connection：浏览器与服务器之间连接的类型。
  Cookie：当前页面设置的任何 Cookie
  Host：发出请求的页面所在的域
  Referer：发出请求的页面的 URL
  User-Agent：浏览器的用户代理字符串
- 响应头
  Date：表示消息发送的时间，时间的描述格式由 rfc822 定义
  server: 服务器名称
  Connection：浏览器与服务器之间连接的类型
  Cache-Control：控制 HTTP 缓存
  content-type: 表示后面的文档属于什么 MIME 类型
  Pragma：只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存

##### 请求方法

- http/1.1 规定了以下请求方法(注意，都是大写):
  GET: 通常用来获取资源
  HEAD: 获取资源的元信息
  POST: 提交数据，即上传数据
  PUT: 修改数据
  DELETE: 删除资源(几乎用不到)
  CONNECT: 建立连接隧道，用于代理服务器
  OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
  TRACE: 追踪请求-响应的传输路径

- GET、POST 区别

  - 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
  - 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
  - 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在 Request body 请求体中，更适合传输敏感信息。
  - 从**幂等**性的角度，GET 是幂等的，而 POST 不是。(在编程中一个幂等操作的特点是其任意多次执行一个方法所产生的影响均与一次执行的影响相同)
  - 从 TCP 的角度，GET 请求会产生一个 TCP 数据包，把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包。GET 浏览器把 http header 和 data 一起发出去，响应成功 200，POST 先发送 header，响应 100 continue，再发送 data，响应成功 200。(并不是所有的浏览器都会发送两次数据包，Firefox 就发送一次，它的 POST 请求只发一个 TCP 包)

- PUT、POST 区别
  PUT 和 POST 都有更改指定 URI 的语义，但 PUT 被定义为**幂等**的方法，而 POST 则不是，多次调用会产生不同的结果。也就是说：

  - PUT：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以 PUT 用来改资源）
  - POST：后一个请求不会把第一个请求覆盖掉。（所以 Post 用来增资源）

- OPTIONS
  主要用途有两个：
  - 获取服务器支持的所有 HTTP 请求方法；
  - 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

##### HTTP 状态码

1xx: 指示信息——表示请求已接收，继续处理。
2xx: 成功——表示请求成功处理完毕。
3xx: 重定向——表示要完成请求必须进行进一步操作。
4xx: 客户端错误——表示请求有语法错误或请求无法实现。
5xx: 服务端错误——表示服务器未能实现合法的请求。

- **状态码** - **描述**

  - `00` - Continue 客户端应继续其请求
  - `101` - Switching Protocols 服务器根据客户端的请求切换协议。只能切换到更高级的协议。如果服务器同意变更，就会发送状态码 101。
  - `200` - OK 请求成功。通常在响应体中放有数据。
  - `204` - No Content 含义与 200 相同，但响应头后没有 body 数据。
  - `206` - Partial Content 已完成指定范围的请求(带 Range 头的 GET 请求)，场景如 video,audio 播放文件较大,文件分片和断点续传时
  - `301` - Moved Permanently 永久重定向
  - `302` - Found 临时重定向
  - `304` - Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。可以使用缓存的资源，不用在服务器获取。当协商缓存命中时会返回这个状态码。
  - `400` - Bad Request 请求有语法错误
  - `401` - Unauthorized 没有权限访问
  - `403` - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
  - `404` - Not Found 请求资源不存在
  - `408` - Request Time-out 服务器等待客户端发送的请求时间过长，超时
  - `500` - Internal Server Error 服务器内部错误，无法完成请求
  - `501` - Not Implemented 表示客户端请求的功能还不支持，无法完成请求
  - `503` - Service Unavailable 请求未完成，因服务器过载、宕机或维护等

- 301 302 区别
  - 301 重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用 301 来做转址。
  - 302 状态码应用的典型场景是服务器页面路径的重新规划。
    常见场景有百度，知乎、简书等等。比如说我们要在百度进入菜鸟教程，搜索出来后有一系列的列表，我们可以选择一个去进行一个点击。点击的那个不会直接进入菜鸟教程，而是先跳转到百度设置的一个临时地址，之后再跳转到菜鸟教程真实的地址。

##### 持久连接

- HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。以当年的通信情况，都是进行容量很小的文本传输，所以问题不大。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。 **图 1**
  <image src="images/2024-03-31-00-54-00.png" style="zoom:30%;"/> <image src="images/2024-03-31-00-55-14.png" style="zoom:25%;"/><image src="images/2024-03-31-01-08-19.png" style="zoom:30%;"/>
- 为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。**图 2**
- 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，也使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。

- 管线化（pipelining）**图 3**
- HTTP 管线化是将多个 HTTP request 整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过永久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持），并且只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。

- keep-alive
  HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接，这就是长连接。
  - HTTP1.0 版本默认没有 Keep-alive ，所以要想连接得到保持，必须手动配置发送 Connection: keep-alive 字段。若想断开 keep-alive 连接，需发送 Connection:close 字段；
  - HTTP1.1 规定了默认保持长连接，数据传输完成了保持 TCP 连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 Connection：close 首部字段。
  - 开启 Keep-Alive 的优点：
    - 较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）；
    - 允许请求和应答的 HTTP 管线化；
    - 降低拥塞控制 （TCP 连接减少了）；
    - 减少了后续请求的延迟（⽆需再进⾏握⼿）；
    - 报告错误⽆需关闭 TCP 连接；
  - 开启 Keep-Alive 的缺点： - 长时间的 Tcp 连接容易导致系统资源无效占用，浪费系统资源。
    ![](images/2024-03-31-19-14-00.png)

##### HTTP 1.0、1.1 区别

- 连接方面，http1.0 默认使用非持久连接，而 http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
  http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
  http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

##### 加载多张图片

在 HTTP 1 下，浏览器对一个域名下最大 TCP 连接数为 6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
在 HTTP 2 下，可以一瞬间加载出来很多资源，因为，HTTP2 支持多路复用，可以在一个 TCP 连接中发送多个 HTTP 请求。

##### 队头堵塞

HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。**解决方案**：

- 并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
- 域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

##### HTTP 版本

- 1.1

  - HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等
  - HTTP/1.1 允许范围请求，即在请求头中加入 Range 头部
  - HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部，以区分同一个物理主机中的不同虚拟主机的域名
  - HTTP/1.1 默认开启持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。

- 2
  - 新的二进制格式： HTTP/1.x 的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。二进制则不同，只识别 0 和 1 的组合。
  - 多路复用： HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行，极大的提高传输性能。
  - 头部压缩： HTTP/1.x 的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表，既避免了重复头部的传输，又减小了需要传输的大小。
  - 服务端推送：这里的服务端推送指把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。
- 3
  - 避免包阻塞： 多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题，TCP 需要等待该包重传后，才能继续传输其它流的数据包。但在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。
  - 快速重启会话： 普通基于 tcp 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。

#### TCP

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。特点：

- 面向连接：发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。
- 仅支持单播传输：每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
- 面向字节流：TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
- 可靠传输：对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
- 提供拥塞控制：当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞。
- 提供全双工通信：TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段。

#### UDP

用户数据报协议（UDP，User Datagram Protocol）是一个无连接的传输协议。特点：无连接、不可靠、快速传输。特点：

- 面向无连接：UDP 不需要三次握手建立连接的，想发数据就可以开始发送了。
- 有单播，多播，广播的功能
- UDP 是面向报文的
  发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。
- 不可靠性：首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
- 头部开销小，传输高效。UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多。

#### TCP 与 UDP

| 对比         | UDP         | TCP                            |
| ------------ | ----------- | ------------------------------ |
| 是否连接     | 无连接      | 面向连接                       |
| 是否可靠     | 不可靠      | 可靠，使用流量控制和拥塞控制   |
| 连接对象个数 | 随意        | 一对一                         |
| 传输方式     | 面向报文    | 面向字节流                     |
| 首部开销     | 首部 8 字节 | 首部最小 20 字节，最大 60 字节 |

#### HTTPS

- HTTP 协议存在的问题：1. 通信使用明文（不加密），内容可能会被窃听 2. 不验证通信方的身份，可能遭遇伪装 3. 无法证明报文的完整性，可能遭遇篡改
- 在 HTTPS 中，使用传输层安全性协议(TLS)或安全套接字协议(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。
  ![](images/2024-03-31-20-04-37.png)

##### 解决内容可能被窃听的问题——加密

- 对称加密+非对称加密
  发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。

##### 解决报文可能遭篡改问题——数字签名

- 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。
- 数字签名有两种功效：
  - 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
  - 数字签名能确定消息的完整性,证明数据是否未被篡改过。
- 数字签名的生成
  将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。
- 前提
  这个过程的前提是接收方知道发送者的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给接收方。
  此时就需要引入了证书颁发机构（Certificate Authority，简称 CA），CA 数量并不多，接收方客户端内置了所有受信任 CA 的证书。CA 对 发送者 的公钥（和其他信息）数字签名后生成证书。

##### 数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

- 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;
- CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
- 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名。
- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

##### HTTPS HTTP 区别

- HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；
- HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协议端口是 443；
- HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全
- HTTPS 比 HTTP 对搜索引擎更友好，利于 SEO,谷歌、百度优先索引 HTTPS 网页

HTTPS 普遍认为性能消耗要大于 HTTP，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。
